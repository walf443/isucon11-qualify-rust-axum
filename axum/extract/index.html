<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Types and traits for extracting data from requests."><meta name="keywords" content="rust, rustlang, rust-lang, extract"><title>axum::extract - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a class="sidebar-logo" href="../../axum/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.png" alt="logo"></div>
        </a><h2 class="location">Module extract</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></div><div id="sidebar-vars" data-name="extract" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../axum/index.html"><img class="rust-logo" src="../../rust-logo.png" alt="logo"></a><nav class="sub"><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">axum</a>::<wbr><a class="mod" href="#">extract</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/axum/extract/mod.rs.html#1-103" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Types and traits for extracting data from requests.</p>
<p>A handler function is an async function that takes any number of
“extractors” as arguments. An extractor is a type that implements
<a href="trait.FromRequest.html"><code>FromRequest</code></a>.</p>
<p>For example, <a href="../struct.Json.html" title="Json"><code>Json</code></a> is an extractor that consumes the request body and
deserializes it as JSON into some target type:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">axum</span>::{
    <span class="ident">extract::Json</span>,
    <span class="ident">routing::post</span>,
    <span class="ident">handler::Handler</span>,
    <span class="ident">Router</span>,
};
<span class="kw">use</span> <span class="ident">serde::Deserialize</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Deserialize</span>)]</span>
<span class="kw">struct</span> <span class="ident">CreateUser</span> {
    <span class="ident">email</span>: <span class="ident">String</span>,
    <span class="ident">password</span>: <span class="ident">String</span>,
}

<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">create_user</span>(<span class="ident">Json</span>(<span class="ident">payload</span>): <span class="ident">Json</span><span class="op">&lt;</span><span class="ident">CreateUser</span><span class="op">&gt;</span>) {
    <span class="comment">// ...</span>
}

<span class="kw">let</span> <span class="ident">app</span> <span class="op">=</span> <span class="ident">Router::new</span>().<span class="ident">route</span>(<span class="string">&quot;/users&quot;</span>, <span class="ident">post</span>(<span class="ident">create_user</span>));</code></pre></div>
<h2 id="common-extractors" class="section-header"><a href="#common-extractors">Common extractors</a></h2>
<p>Some commonly used extractors are:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">axum</span>::{
    <span class="ident">extract</span>::{<span class="ident">Json</span>, <span class="ident">TypedHeader</span>, <span class="ident">Path</span>, <span class="ident">Extension</span>, <span class="ident">Query</span>},
    <span class="ident">routing::post</span>,
    <span class="ident">headers::UserAgent</span>,
    <span class="ident">http</span>::{<span class="ident">Request</span>, <span class="ident">header::HeaderMap</span>},
    <span class="ident">body</span>::{<span class="ident">Bytes</span>, <span class="ident">Body</span>},
    <span class="ident">Router</span>,
};
<span class="kw">use</span> <span class="ident">serde_json::Value</span>;
<span class="kw">use</span> <span class="ident">std::collections::HashMap</span>;

<span class="comment">// `Path` gives you the path parameters and deserializes them. See its docs for</span>
<span class="comment">// more details</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">path</span>(<span class="ident">Path</span>(<span class="ident">user_id</span>): <span class="ident">Path</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>) {}

<span class="comment">// `Query` gives you the query parameters and deserializes them.</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">query</span>(<span class="ident">Query</span>(<span class="ident">params</span>): <span class="ident">Query</span><span class="op">&lt;</span><span class="ident">HashMap</span><span class="op">&lt;</span><span class="ident">String</span>, <span class="ident">String</span><span class="op">&gt;</span><span class="op">&gt;</span>) {}

<span class="comment">// `HeaderMap` gives you all the headers</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">headers</span>(<span class="ident">headers</span>: <span class="ident">HeaderMap</span>) {}

<span class="comment">// `TypedHeader` can be used to extract a single header</span>
<span class="comment">// note this requires you&#39;ve enabled axum&#39;s `headers` feature</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">user_agent</span>(<span class="ident">TypedHeader</span>(<span class="ident">user_agent</span>): <span class="ident">TypedHeader</span><span class="op">&lt;</span><span class="ident">UserAgent</span><span class="op">&gt;</span>) {}

<span class="comment">// `String` consumes the request body and ensures it is valid utf-8</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">string</span>(<span class="ident">body</span>: <span class="ident">String</span>) {}

<span class="comment">// `Bytes` gives you the raw request body</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">bytes</span>(<span class="ident">body</span>: <span class="ident">Bytes</span>) {}

<span class="comment">// We&#39;ve already seen `Json` for parsing the request body as json</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">json</span>(<span class="ident">Json</span>(<span class="ident">payload</span>): <span class="ident">Json</span><span class="op">&lt;</span><span class="ident">Value</span><span class="op">&gt;</span>) {}

<span class="comment">// `Request` gives you the whole request for maximum control</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">request</span>(<span class="ident">request</span>: <span class="ident">Request</span><span class="op">&lt;</span><span class="ident">Body</span><span class="op">&gt;</span>) {}

<span class="comment">// `Extension` extracts data from &quot;request extensions&quot;</span>
<span class="comment">// This is commonly used to share state with handlers</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">extension</span>(<span class="ident">Extension</span>(<span class="ident">state</span>): <span class="ident">Extension</span><span class="op">&lt;</span><span class="ident">State</span><span class="op">&gt;</span>) {}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>)]</span>
<span class="kw">struct</span> <span class="ident">State</span> { <span class="comment">/* ... */</span> }

<span class="kw">let</span> <span class="ident">app</span> <span class="op">=</span> <span class="ident">Router::new</span>()
    .<span class="ident">route</span>(<span class="string">&quot;/path/:user_id&quot;</span>, <span class="ident">post</span>(<span class="ident">path</span>))
    .<span class="ident">route</span>(<span class="string">&quot;/query&quot;</span>, <span class="ident">post</span>(<span class="ident">query</span>))
    .<span class="ident">route</span>(<span class="string">&quot;/user_agent&quot;</span>, <span class="ident">post</span>(<span class="ident">user_agent</span>))
    .<span class="ident">route</span>(<span class="string">&quot;/headers&quot;</span>, <span class="ident">post</span>(<span class="ident">headers</span>))
    .<span class="ident">route</span>(<span class="string">&quot;/string&quot;</span>, <span class="ident">post</span>(<span class="ident">string</span>))
    .<span class="ident">route</span>(<span class="string">&quot;/bytes&quot;</span>, <span class="ident">post</span>(<span class="ident">bytes</span>))
    .<span class="ident">route</span>(<span class="string">&quot;/json&quot;</span>, <span class="ident">post</span>(<span class="ident">json</span>))
    .<span class="ident">route</span>(<span class="string">&quot;/request&quot;</span>, <span class="ident">post</span>(<span class="ident">request</span>))
    .<span class="ident">route</span>(<span class="string">&quot;/extension&quot;</span>, <span class="ident">post</span>(<span class="ident">extension</span>));</code></pre></div>
<h2 id="applying-multiple-extractors" class="section-header"><a href="#applying-multiple-extractors">Applying multiple extractors</a></h2>
<p>You can also apply multiple extractors:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">axum</span>::{
    <span class="ident">extract</span>::{<span class="ident">Path</span>, <span class="ident">Query</span>},
    <span class="ident">routing::get</span>,
    <span class="ident">Router</span>,
};
<span class="kw">use</span> <span class="ident">uuid::Uuid</span>;
<span class="kw">use</span> <span class="ident">serde::Deserialize</span>;

<span class="kw">let</span> <span class="ident">app</span> <span class="op">=</span> <span class="ident">Router::new</span>().<span class="ident">route</span>(<span class="string">&quot;/users/:id/things&quot;</span>, <span class="ident">get</span>(<span class="ident">get_user_things</span>));

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Deserialize</span>)]</span>
<span class="kw">struct</span> <span class="ident">Pagination</span> {
    <span class="ident">page</span>: <span class="ident">usize</span>,
    <span class="ident">per_page</span>: <span class="ident">usize</span>,
}

<span class="kw">impl</span> <span class="ident">Default</span> <span class="kw">for</span> <span class="ident">Pagination</span> {
    <span class="kw">fn</span> <span class="ident">default</span>() -&gt; <span class="self">Self</span> {
        <span class="self">Self</span> { <span class="ident">page</span>: <span class="number">1</span>, <span class="ident">per_page</span>: <span class="number">30</span> }
    }
}

<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">get_user_things</span>(
    <span class="ident">Path</span>(<span class="ident">user_id</span>): <span class="ident">Path</span><span class="op">&lt;</span><span class="ident">Uuid</span><span class="op">&gt;</span>,
    <span class="ident">pagination</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Query</span><span class="op">&lt;</span><span class="ident">Pagination</span><span class="op">&gt;</span><span class="op">&gt;</span>,
) {
    <span class="kw">let</span> <span class="ident">Query</span>(<span class="ident">pagination</span>) <span class="op">=</span> <span class="ident">pagination</span>.<span class="ident">unwrap_or_default</span>();

    <span class="comment">// ...</span>
}</code></pre></div>
<p>Take care of the order in which you apply extractors as some extractors
mutate the request.</p>
<p>For example using <a href="https://docs.rs/http/latest/http/header/struct.HeaderMap.html"><code>HeaderMap</code></a> as an extractor will make the headers
inaccessible for other extractors on the handler. If you need to extract
individual headers <em>and</em> a <a href="https://docs.rs/http/latest/http/header/struct.HeaderMap.html"><code>HeaderMap</code></a> make sure to apply the extractor of
individual headers first:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">axum</span>::{
    <span class="ident">extract::TypedHeader</span>,
    <span class="ident">routing::get</span>,
    <span class="ident">headers::UserAgent</span>,
    <span class="ident">http::header::HeaderMap</span>,
    <span class="ident">Router</span>,
};

<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">handler</span>(
    <span class="ident">TypedHeader</span>(<span class="ident">user_agent</span>): <span class="ident">TypedHeader</span><span class="op">&lt;</span><span class="ident">UserAgent</span><span class="op">&gt;</span>,
    <span class="ident">all_headers</span>: <span class="ident">HeaderMap</span>,
) {
    <span class="comment">// ...</span>
}

<span class="kw">let</span> <span class="ident">app</span> <span class="op">=</span> <span class="ident">Router::new</span>().<span class="ident">route</span>(<span class="string">&quot;/&quot;</span>, <span class="ident">get</span>(<span class="ident">handler</span>));</code></pre></div>
<p>Extractors that consume the request body can also only be applied once as
well as <a href="https://docs.rs/http/latest/http/struct.Request.html"><code>Request</code></a>, which consumes the entire request:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">axum</span>::{
    <span class="ident">routing::get</span>,
    <span class="ident">http::Request</span>,
    <span class="ident">body::Body</span>,
    <span class="ident">Router</span>,
};

<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">handler</span>(<span class="ident">request</span>: <span class="ident">Request</span><span class="op">&lt;</span><span class="ident">Body</span><span class="op">&gt;</span>) {
    <span class="comment">// ...</span>
}

<span class="kw">let</span> <span class="ident">app</span> <span class="op">=</span> <span class="ident">Router::new</span>().<span class="ident">route</span>(<span class="string">&quot;/&quot;</span>, <span class="ident">get</span>(<span class="ident">handler</span>));</code></pre></div>
<p>Extractors always run in the order of the function parameters that is from
left to right.</p>
<h2 id="optional-extractors" class="section-header"><a href="#optional-extractors">Optional extractors</a></h2>
<p>All extractors defined in axum will reject the request if it doesn’t match.
If you wish to make an extractor optional you can wrap it in <code>Option</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">axum</span>::{
    <span class="ident">extract::Json</span>,
    <span class="ident">routing::post</span>,
    <span class="ident">Router</span>,
};
<span class="kw">use</span> <span class="ident">serde_json::Value</span>;

<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">create_user</span>(<span class="ident">payload</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Json</span><span class="op">&lt;</span><span class="ident">Value</span><span class="op">&gt;</span><span class="op">&gt;</span>) {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">payload</span>) <span class="op">=</span> <span class="ident">payload</span> {
        <span class="comment">// We got a valid JSON payload</span>
    } <span class="kw">else</span> {
        <span class="comment">// Payload wasn&#39;t valid JSON</span>
    }
}

<span class="kw">let</span> <span class="ident">app</span> <span class="op">=</span> <span class="ident">Router::new</span>().<span class="ident">route</span>(<span class="string">&quot;/users&quot;</span>, <span class="ident">post</span>(<span class="ident">create_user</span>));</code></pre></div>
<p>Wrapping extractors in <code>Result</code> makes them optional and gives you the reason
the extraction failed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">axum</span>::{
    <span class="ident">extract</span>::{<span class="ident">Json</span>, <span class="ident">rejection::JsonRejection</span>},
    <span class="ident">routing::post</span>,
    <span class="ident">Router</span>,
};
<span class="kw">use</span> <span class="ident">serde_json::Value</span>;

<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">create_user</span>(<span class="ident">payload</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">Json</span><span class="op">&lt;</span><span class="ident">Value</span><span class="op">&gt;</span>, <span class="ident">JsonRejection</span><span class="op">&gt;</span>) {
    <span class="kw">match</span> <span class="ident">payload</span> {
        <span class="prelude-val">Ok</span>(<span class="ident">payload</span>) =&gt; {
            <span class="comment">// We got a valid JSON payload</span>
        }
        <span class="prelude-val">Err</span>(<span class="ident">JsonRejection::MissingJsonContentType</span>(<span class="kw">_</span>)) =&gt; {
            <span class="comment">// Request didn&#39;t have `Content-Type: application/json`</span>
            <span class="comment">// header</span>
        }
        <span class="prelude-val">Err</span>(<span class="ident">JsonRejection::InvalidJsonBody</span>(<span class="kw">_</span>)) =&gt; {
            <span class="comment">// Couldn&#39;t deserialize the body into the target type</span>
        }
        <span class="prelude-val">Err</span>(<span class="ident">JsonRejection::BytesRejection</span>(<span class="kw">_</span>)) =&gt; {
            <span class="comment">// Failed to extract the request body</span>
        }
        <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; {
            <span class="comment">// `JsonRejection` is marked `#[non_exhaustive]` so match must</span>
            <span class="comment">// include a catch-all case.</span>
        }
    }
}

<span class="kw">let</span> <span class="ident">app</span> <span class="op">=</span> <span class="ident">Router::new</span>().<span class="ident">route</span>(<span class="string">&quot;/users&quot;</span>, <span class="ident">post</span>(<span class="ident">create_user</span>));</code></pre></div>
<h2 id="customizing-extractor-responses" class="section-header"><a href="#customizing-extractor-responses">Customizing extractor responses</a></h2>
<p>If an extractor fails it will return a response with the error and your
handler will not be called. To customize the error response you have a two
options:</p>
<ol>
<li>Use <code>Result&lt;T, T::Rejection&gt;</code> as your extractor like shown in <a href="#optional-extractors">“Optional
extractors”</a>. This works well if you’re only using
the extractor in a single handler.</li>
<li>Create your own extractor that in its <a href="trait.FromRequest.html" title="FromRequest"><code>FromRequest</code></a> implemention calls
one of axum’s built in extractors but returns a different response for
rejections. See the <a href="https://github.com/tokio-rs/axum/blob/main/examples/customize-extractor-error/src/main.rs">customize-extractor-error</a> example for more details.</li>
</ol>
<h2 id="accessing-inner-errors" class="section-header"><a href="#accessing-inner-errors">Accessing inner errors</a></h2>
<p>axum’s built-in extractors don’t directly expose the inner error. This gives us
more flexibility and allows us to change internal implementations without
breaking the public API.</p>
<p>For example that means while <a href="../struct.Json.html" title="Json"><code>Json</code></a> is implemented using <a href="../../serde_json/index.html" title="serde_json"><code>serde_json</code></a> it
doesn’t directly expose the <a href="../../serde_json/error/struct.Error.html" title="serde_json::Error"><code>serde_json::Error</code></a> thats contained in
<a href="rejection/enum.JsonRejection.html#variant.InvalidJsonBody" title="JsonRejection::InvalidJsonBody"><code>JsonRejection::InvalidJsonBody</code></a>. However it is still possible to access via
methods from <a href="https://doc.rust-lang.org/1.59.0/std/error/trait.Error.html" title="std::error::Error"><code>std::error::Error</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">axum</span>::{
    <span class="ident">extract</span>::{<span class="ident">Json</span>, <span class="ident">rejection::JsonRejection</span>},
    <span class="ident">response::IntoResponse</span>,
    <span class="ident">http::StatusCode</span>,
};
<span class="kw">use</span> <span class="ident">serde_json</span>::{<span class="ident">json</span>, <span class="ident">Value</span>};

<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">handler</span>(<span class="ident">result</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">Json</span><span class="op">&lt;</span><span class="ident">Value</span><span class="op">&gt;</span>, <span class="ident">JsonRejection</span><span class="op">&gt;</span>) -&gt; <span class="kw">impl</span> <span class="ident">IntoResponse</span> {
    <span class="kw">match</span> <span class="ident">result</span> {
        <span class="comment">// if the client sent valid JSON then we&#39;re good</span>
        <span class="prelude-val">Ok</span>(<span class="ident">Json</span>(<span class="ident">payload</span>)) =&gt; <span class="prelude-val">Ok</span>(<span class="ident">Json</span>(<span class="macro">json!</span>({ <span class="string">&quot;payload&quot;</span>: <span class="ident">payload</span> }))),

        <span class="prelude-val">Err</span>(<span class="ident">err</span>) =&gt; <span class="kw">match</span> <span class="ident">err</span> {
            <span class="comment">// attempt to extract the inner `serde_json::Error`, if that</span>
            <span class="comment">// succeeds we can provide a more specific error</span>
            <span class="ident">JsonRejection::InvalidJsonBody</span>(<span class="ident">err</span>) =&gt; {
                <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">serde_json_err</span>) <span class="op">=</span> <span class="ident">find_error_source</span>::<span class="op">&lt;</span><span class="ident">serde_json::Error</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">err</span>) {
                    <span class="prelude-val">Err</span>((
                        <span class="ident">StatusCode::BAD_REQUEST</span>,
                        <span class="macro">format!</span>(
                            <span class="string">&quot;Invalid JSON at line {} column {}&quot;</span>,
                            <span class="ident">serde_json_err</span>.<span class="ident">line</span>(),
                            <span class="ident">serde_json_err</span>.<span class="ident">column</span>()
                        ),
                    ))
                } <span class="kw">else</span> {
                    <span class="prelude-val">Err</span>((<span class="ident">StatusCode::BAD_REQUEST</span>, <span class="string">&quot;Unknown error&quot;</span>.<span class="ident">to_string</span>()))
                }
            }
            <span class="comment">// handle other rejections from the `Json` extractor</span>
            <span class="ident">JsonRejection::MissingJsonContentType</span>(<span class="kw">_</span>) =&gt; <span class="prelude-val">Err</span>((
                <span class="ident">StatusCode::BAD_REQUEST</span>,
                <span class="string">&quot;Missing `Content-Type: application/json` header&quot;</span>.<span class="ident">to_string</span>(),
            )),
            <span class="ident">JsonRejection::BytesRejection</span>(<span class="kw">_</span>) =&gt; <span class="prelude-val">Err</span>((
                <span class="ident">StatusCode::INTERNAL_SERVER_ERROR</span>,
                <span class="string">&quot;Failed to buffer request body&quot;</span>.<span class="ident">to_string</span>(),
            )),
            <span class="ident">JsonRejection::HeadersAlreadyExtracted</span>(<span class="kw">_</span>) =&gt; <span class="prelude-val">Err</span>((
                <span class="ident">StatusCode::INTERNAL_SERVER_ERROR</span>,
                <span class="string">&quot;Headers already extracted&quot;</span>.<span class="ident">to_string</span>(),
            )),
            <span class="comment">// we must provide a catch-all case since `JsonRejection` is marked</span>
            <span class="comment">// `#[non_exhaustive]`</span>
            <span class="kw">_</span> =&gt; <span class="prelude-val">Err</span>((
                <span class="ident">StatusCode::INTERNAL_SERVER_ERROR</span>,
                <span class="string">&quot;Unknown error&quot;</span>.<span class="ident">to_string</span>(),
            )),
        },
    }
}

<span class="comment">// attempt to downcast `err` into a `T` and if that fails recursively try and</span>
<span class="comment">// downcast `err`&#39;s source</span>
<span class="kw">fn</span> <span class="ident">find_error_source</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">err</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> (<span class="kw">dyn</span> <span class="ident">Error</span> <span class="op">+</span> <span class="lifetime">&#39;static</span>)) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">Error</span> <span class="op">+</span> <span class="lifetime">&#39;static</span>,
{
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">err</span>) <span class="op">=</span> <span class="ident">err</span>.<span class="ident">downcast_ref</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>() {
        <span class="prelude-val">Some</span>(<span class="ident">err</span>)
    } <span class="kw">else</span> <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">source</span>) <span class="op">=</span> <span class="ident">err</span>.<span class="ident">source</span>() {
        <span class="ident">find_error_source</span>(<span class="ident">source</span>)
    } <span class="kw">else</span> {
        <span class="prelude-val">None</span>
    }
}</code></pre></div>
<p>Note that while this approach works it might break in the future if axum changes
its implementation to use a different error type internally. Such changes might
happen without major breaking versions.</p>
<h2 id="defining-custom-extractors" class="section-header"><a href="#defining-custom-extractors">Defining custom extractors</a></h2>
<p>You can also define your own extractors by implementing <a href="trait.FromRequest.html" title="FromRequest"><code>FromRequest</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">axum</span>::{
    <span class="ident">async_trait</span>,
    <span class="ident">extract</span>::{<span class="ident">FromRequest</span>, <span class="ident">RequestParts</span>},
    <span class="ident">routing::get</span>,
    <span class="ident">Router</span>,
};
<span class="kw">use</span> <span class="ident">http</span>::{<span class="ident">StatusCode</span>, <span class="ident">header</span>::{<span class="ident">HeaderValue</span>, <span class="ident">USER_AGENT</span>}};

<span class="kw">struct</span> <span class="ident">ExtractUserAgent</span>(<span class="ident">HeaderValue</span>);

<span class="attribute">#[<span class="ident">async_trait</span>]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">B</span><span class="op">&gt;</span> <span class="ident">FromRequest</span><span class="op">&lt;</span><span class="ident">B</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">ExtractUserAgent</span>
<span class="kw">where</span>
    <span class="ident">B</span>: <span class="ident">Send</span>,
{
    <span class="kw">type</span> <span class="ident">Rejection</span> <span class="op">=</span> (<span class="ident">StatusCode</span>, <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>);

    <span class="kw">async</span> <span class="kw">fn</span> <span class="ident">from_request</span>(<span class="ident">req</span>: <span class="kw-2">&amp;mut</span> <span class="ident">RequestParts</span><span class="op">&lt;</span><span class="ident">B</span><span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>, <span class="ident"><span class="self">Self</span>::Rejection</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">user_agent</span> <span class="op">=</span> <span class="ident">req</span>.<span class="ident">headers</span>().<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">headers</span><span class="op">|</span> <span class="ident">headers</span>.<span class="ident">get</span>(<span class="ident">USER_AGENT</span>));

        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">user_agent</span>) <span class="op">=</span> <span class="ident">user_agent</span> {
            <span class="prelude-val">Ok</span>(<span class="ident">ExtractUserAgent</span>(<span class="ident">user_agent</span>.<span class="ident">clone</span>()))
        } <span class="kw">else</span> {
            <span class="prelude-val">Err</span>((<span class="ident">StatusCode::BAD_REQUEST</span>, <span class="string">&quot;`User-Agent` header is missing&quot;</span>))
        }
    }
}

<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">handler</span>(<span class="ident">ExtractUserAgent</span>(<span class="ident">user_agent</span>): <span class="ident">ExtractUserAgent</span>) {
    <span class="comment">// ...</span>
}

<span class="kw">let</span> <span class="ident">app</span> <span class="op">=</span> <span class="ident">Router::new</span>().<span class="ident">route</span>(<span class="string">&quot;/foo&quot;</span>, <span class="ident">get</span>(<span class="ident">handler</span>));</code></pre></div>
<h2 id="accessing-other-extractors-in-fromrequest-implementations" class="section-header"><a href="#accessing-other-extractors-in-fromrequest-implementations">Accessing other extractors in <code>FromRequest</code> implementations</a></h2>
<p>When defining custom extractors you often need to access another extractors
in your implementation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">axum</span>::{
    <span class="ident">async_trait</span>,
    <span class="ident">extract</span>::{<span class="ident">Extension</span>, <span class="ident">FromRequest</span>, <span class="ident">RequestParts</span>, <span class="ident">TypedHeader</span>},
    <span class="ident">headers</span>::{<span class="ident">authorization::Bearer</span>, <span class="ident">Authorization</span>},
    <span class="ident">http::StatusCode</span>,
    <span class="ident">response</span>::{<span class="ident">IntoResponse</span>, <span class="ident">Response</span>},
    <span class="ident">routing::get</span>,
    <span class="ident">AddExtensionLayer</span>, <span class="ident">Router</span>,
};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>)]</span>
<span class="kw">struct</span> <span class="ident">State</span> {
    <span class="comment">// ...</span>
}

<span class="kw">struct</span> <span class="ident">AuthenticatedUser</span> {
    <span class="comment">// ...</span>
}

<span class="attribute">#[<span class="ident">async_trait</span>]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">B</span><span class="op">&gt;</span> <span class="ident">FromRequest</span><span class="op">&lt;</span><span class="ident">B</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">AuthenticatedUser</span>
<span class="kw">where</span>
    <span class="ident">B</span>: <span class="ident">Send</span>,
{
    <span class="kw">type</span> <span class="ident">Rejection</span> <span class="op">=</span> <span class="ident">Response</span>;

    <span class="kw">async</span> <span class="kw">fn</span> <span class="ident">from_request</span>(<span class="ident">req</span>: <span class="kw-2">&amp;mut</span> <span class="ident">RequestParts</span><span class="op">&lt;</span><span class="ident">B</span><span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>, <span class="ident"><span class="self">Self</span>::Rejection</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">TypedHeader</span>(<span class="ident">Authorization</span>(<span class="ident">token</span>)) <span class="op">=</span> 
            <span class="ident">TypedHeader</span>::<span class="op">&lt;</span><span class="ident">Authorization</span><span class="op">&lt;</span><span class="ident">Bearer</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="ident">::from_request</span>(<span class="ident">req</span>)
                .<span class="kw">await</span>
                .<span class="ident">map_err</span>(<span class="op">|</span><span class="ident">err</span><span class="op">|</span> <span class="ident">err</span>.<span class="ident">into_response</span>())<span class="question-mark">?</span>;

        <span class="kw">let</span> <span class="ident">Extension</span>(<span class="ident">state</span>): <span class="ident">Extension</span><span class="op">&lt;</span><span class="ident">State</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Extension::from_request</span>(<span class="ident">req</span>)
            .<span class="kw">await</span>
            .<span class="ident">map_err</span>(<span class="op">|</span><span class="ident">err</span><span class="op">|</span> <span class="ident">err</span>.<span class="ident">into_response</span>())<span class="question-mark">?</span>;

        <span class="comment">// actually perform the authorization...</span>
        <span class="macro">unimplemented!</span>()
    }
}

<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">handler</span>(<span class="ident">user</span>: <span class="ident">AuthenticatedUser</span>) {
    <span class="comment">// ...</span>
}

<span class="kw">let</span> <span class="ident">state</span> <span class="op">=</span> <span class="ident">State</span> { <span class="comment">/* ... */</span> };

<span class="kw">let</span> <span class="ident">app</span> <span class="op">=</span> <span class="ident">Router::new</span>().<span class="ident">route</span>(<span class="string">&quot;/&quot;</span>, <span class="ident">get</span>(<span class="ident">handler</span>)).<span class="ident">layer</span>(<span class="ident">AddExtensionLayer::new</span>(<span class="ident">state</span>));</code></pre></div>
<h2 id="request-body-extractors" class="section-header"><a href="#request-body-extractors">Request body extractors</a></h2>
<p>Most of the time your request body type will be <a href="../../hyper/body/body/struct.Body.html"><code>body::Body</code></a> (a re-export
of <a href="../../hyper/body/body/struct.Body.html" title="hyper::Body"><code>hyper::Body</code></a>), which is directly supported by all extractors.</p>
<p>However if you’re applying a tower middleware that changes the request body type
you might have to apply a different body type to some extractors:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std</span>::{
    <span class="ident">task</span>::{<span class="ident">Context</span>, <span class="ident">Poll</span>},
    <span class="ident">pin::Pin</span>,
};
<span class="kw">use</span> <span class="ident">tower_http::map_request_body::MapRequestBodyLayer</span>;
<span class="kw">use</span> <span class="ident">axum</span>::{
    <span class="ident">extract</span>::{<span class="self">self</span>, <span class="ident">BodyStream</span>},
    <span class="ident">body</span>::{<span class="ident">Body</span>, <span class="ident">HttpBody</span>},
    <span class="ident">routing::get</span>,
    <span class="ident">http</span>::{<span class="ident">header::HeaderMap</span>, <span class="ident">Request</span>},
    <span class="ident">Router</span>,
};

<span class="kw">struct</span> <span class="ident">MyBody</span><span class="op">&lt;</span><span class="ident">B</span><span class="op">&gt;</span>(<span class="ident">B</span>);

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">B</span><span class="op">&gt;</span> <span class="ident">HttpBody</span> <span class="kw">for</span> <span class="ident">MyBody</span><span class="op">&lt;</span><span class="ident">B</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">B</span>: <span class="ident">HttpBody</span> <span class="op">+</span> <span class="ident">Unpin</span>,
{
    <span class="kw">type</span> <span class="ident">Data</span> <span class="op">=</span> <span class="ident">B::Data</span>;
    <span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="ident">B::Error</span>;

    <span class="kw">fn</span> <span class="ident">poll_data</span>(
        <span class="kw-2">mut</span> <span class="self">self</span>: <span class="ident">Pin</span><span class="op">&lt;</span><span class="kw-2">&amp;mut</span> <span class="self">Self</span><span class="op">&gt;</span>,
        <span class="ident">cx</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Context</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>,
    ) -&gt; <span class="ident">Poll</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Data</span>, <span class="ident"><span class="self">Self</span>::Error</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span> {
        <span class="ident">Pin::new</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>.<span class="number">0</span>).<span class="ident">poll_data</span>(<span class="ident">cx</span>)
    }

    <span class="kw">fn</span> <span class="ident">poll_trailers</span>(
        <span class="kw-2">mut</span> <span class="self">self</span>: <span class="ident">Pin</span><span class="op">&lt;</span><span class="kw-2">&amp;mut</span> <span class="self">Self</span><span class="op">&gt;</span>,
        <span class="ident">cx</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Context</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>,
    ) -&gt; <span class="ident">Poll</span><span class="op">&lt;</span><span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">HeaderMap</span><span class="op">&gt;</span>, <span class="ident"><span class="self">Self</span>::Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
        <span class="ident">Pin::new</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>.<span class="number">0</span>).<span class="ident">poll_trailers</span>(<span class="ident">cx</span>)
    }
}

<span class="kw">let</span> <span class="ident">app</span> <span class="op">=</span> <span class="ident">Router::new</span>()
    .<span class="ident">route</span>(
        <span class="string">&quot;/string&quot;</span>,
        <span class="comment">// `String` works directly with any body type</span>
        <span class="ident">get</span>(<span class="op">|</span><span class="kw">_</span>: <span class="ident">String</span><span class="op">|</span> <span class="kw">async</span> {})
    )
    .<span class="ident">route</span>(
        <span class="string">&quot;/body&quot;</span>,
        <span class="comment">// `extract::Body` defaults to `axum::body::Body`</span>
        <span class="comment">// but can be customized</span>
        <span class="ident">get</span>(<span class="op">|</span><span class="kw">_</span>: <span class="ident">extract::RawBody</span><span class="op">&lt;</span><span class="ident">MyBody</span><span class="op">&lt;</span><span class="ident">Body</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">|</span> <span class="kw">async</span> {})
    )
    .<span class="ident">route</span>(
        <span class="string">&quot;/body-stream&quot;</span>,
        <span class="comment">// same for `extract::BodyStream`</span>
        <span class="ident">get</span>(<span class="op">|</span><span class="kw">_</span>: <span class="ident">extract::BodyStream</span><span class="op">|</span> <span class="kw">async</span> {}),
    )
    .<span class="ident">route</span>(
        <span class="comment">// and `Request&lt;_&gt;`</span>
        <span class="string">&quot;/request&quot;</span>,
        <span class="ident">get</span>(<span class="op">|</span><span class="kw">_</span>: <span class="ident">Request</span><span class="op">&lt;</span><span class="ident">MyBody</span><span class="op">&lt;</span><span class="ident">Body</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">|</span> <span class="kw">async</span> {})
    )
    <span class="comment">// middleware that changes the request body type</span>
    .<span class="ident">layer</span>(<span class="ident">MapRequestBodyLayer::new</span>(<span class="ident">MyBody</span>));</code></pre></div>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left import-item"><code>pub use crate::<a class="struct" href="../struct.Json.html" title="struct axum::Json">Json</a>;</code></div><div class="item-right docblock-short"></div></div></div><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="connect_info/index.html" title="axum::extract::connect_info mod">connect_info</a></div><div class="item-right docblock-short"><p>Extractor for getting connection information from a client.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="extractor_middleware/index.html" title="axum::extract::extractor_middleware mod">extractor_middleware</a></div><div class="item-right docblock-short"><p>Convert an extractor into a middleware.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="path/index.html" title="axum::extract::path mod">path</a></div><div class="item-right docblock-short"><p>Extractor that will get captures from the URL and parse them using
<a href="../../serde/index.html" title="serde"><code>serde</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="rejection/index.html" title="axum::extract::rejection mod">rejection</a></div><div class="item-right docblock-short"><p>Rejection response types.</p>
</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BodyStream.html" title="axum::extract::BodyStream struct">BodyStream</a></div><div class="item-right docblock-short"><p>Extractor that extracts the request body as a <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ConnectInfo.html" title="axum::extract::ConnectInfo struct">ConnectInfo</a></div><div class="item-right docblock-short"><p>Extractor for getting connection information produced by a <a href="connect_info/trait.Connected.html" title="Connected"><code>Connected</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ContentLengthLimit.html" title="axum::extract::ContentLengthLimit struct">ContentLengthLimit</a></div><div class="item-right docblock-short"><p>Extractor that will reject requests with a body larger than some size.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Extension.html" title="axum::extract::Extension struct">Extension</a></div><div class="item-right docblock-short"><p>Extractor that gets a value from request extensions.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Form.html" title="axum::extract::Form struct">Form</a></div><div class="item-right docblock-short"><p>Extractor that deserializes <code>application/x-www-form-urlencoded</code> requests
into some type.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.MatchedPath.html" title="axum::extract::MatchedPath struct">MatchedPath</a></div><div class="item-right docblock-short"><p>Access the path in the router that matches the request.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.OriginalUri.html" title="axum::extract::OriginalUri struct">OriginalUri</a></div><div class="item-right docblock-short"><p>Extractor that gets the original request URI regardless of nesting.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Path.html" title="axum::extract::Path struct">Path</a></div><div class="item-right docblock-short"><p>Extractor that will get captures from the URL and parse them using
<a href="https://crates.io/crates/serde"><code>serde</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Query.html" title="axum::extract::Query struct">Query</a></div><div class="item-right docblock-short"><p>Extractor that deserializes query strings into some type.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RawBody.html" title="axum::extract::RawBody struct">RawBody</a></div><div class="item-right docblock-short"><p>Extractor that extracts the raw request body.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RawQuery.html" title="axum::extract::RawQuery struct">RawQuery</a></div><div class="item-right docblock-short"><p>Extractor that extracts the raw query string, without parsing it.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RequestParts.html" title="axum::extract::RequestParts struct">RequestParts</a></div><div class="item-right docblock-short"><p>The type used with <a href="trait.FromRequest.html" title="FromRequest"><code>FromRequest</code></a> to extract data from requests.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TypedHeader.html" title="axum::extract::TypedHeader struct">TypedHeader</a></div><div class="item-right docblock-short"><p>Extractor that extracts a typed header value from <a href="../../headers/index.html" title="headers"><code>headers</code></a>.</p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.FromRequest.html" title="axum::extract::FromRequest trait">FromRequest</a></div><div class="item-right docblock-short"><p>Types that can be created from requests.</p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.extractor_middleware.html" title="axum::extract::extractor_middleware fn">extractor_middleware</a></div><div class="item-right docblock-short"><p>Convert an extractor into a middleware.</p>
</div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="axum" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.59.0 (9d1b2106e 2022-02-23)" ></div>
</body></html>